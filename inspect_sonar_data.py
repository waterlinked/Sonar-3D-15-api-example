#!/usr/bin/env python3
"""
Example script to read Sonar 3D-15 data from a file and decode the packets.
The sonar file can be generated with the "save_sonar_data.py" script or in the Sonar GUI (release 1.4.0 or later).

Optionally it can save the RangeImage data to XYZ file format and BitmapImage
to PGM file format.

REQUIREMENTS:
  - Python 3
  - protobuf (pip install protobuf)
  - sonar_3d_15_protocol_pb2.py generated from the Water Linked sonar .proto file

USAGE:
  1. Place this script in the same folder as the "sonar_3d_15_protocol_pb2.py" file (generated by protoc).
  2. Run: python save_sonar_data.py --file <filename> [--save]
  3. Observe the output in the terminal.
"""

import os
import struct
import zlib
import math

# Generated Protobuf definitions for the Sonar 3D-15 protocol
from sonar_3d_15_protocol_pb2 import (
    Packet,
    BitmapImageGreyscale8,
    RangeImage
)

def parse_rip1_packet(data: bytes):
    """
    Parse the RIP1 framing:
      1. Verify the "RIP1" magic header
      2. Verify total_length field matches the data size
      3. Check CRC
      4. Extract payload (proto data) from the packet

    Returns:
      payload (bytes) if valid, or None if there's an error.
    """
    if len(data) < 13:
        print(f"Packet too small: only {len(data)} bytes.")
        return None

    # First 4 bytes are "RIP1"
    magic = data[:4]
    if magic != b'RIP1':
        print(f"Invalid magic: got {magic!r} instead of b'RIP1'.")
        return None

    # Next 4 bytes (little-endian) specify the total packet length
    total_length = struct.unpack('<I', data[4:8])[0]
    if len(data) < total_length:
        print(
            f"Packet truncated: needed {total_length} bytes, got {len(data)}.")
        return None

    # The payload is between offset 8 and (total_length - 4)
    payload = data[8: total_length - 4]

    # Last 4 bytes in the packet is the CRC32
    crc_received = struct.unpack('<I', data[total_length - 4: total_length])[0]
    crc_calculated = zlib.crc32(data[: total_length - 4]) & 0xffffffff
    if crc_calculated != crc_received:
        print(
            f"CRC mismatch: expected 0x{crc_calculated:08x}, got 0x{crc_received:08x}.")
        return None

    return payload


def decode_protobuf_packet(payload: bytes):
    """
    Decode the Protobuf Packet (top-level), which may contain:
      - BitmapImageGreyscale8
      - RangeImage
      - or an unknown message type (google.protobuf.Any)

    Returns:
      (msg_type_name, message_object) if successfully parsed,
      or None if parsing failed.
    """
    # Create a top-level Packet object
    packet = Packet()
    try:
        packet.ParseFromString(payload)
    except Exception as e:
        print(f"Protobuf parse error: {e}")
        return None

    # The actual data is in the .msg field (type google.protobuf.Any)
    any_msg = packet.msg
    if not any_msg.IsInitialized():
        return None

    # Attempt to unpack into BitmapImageGreyscale8
    bmp = BitmapImageGreyscale8()
    if any_msg.Unpack(bmp):
        return ("BitmapImageGreyscale8", bmp)

    # Otherwise, try to unpack into RangeImage
    rng = RangeImage()
    if any_msg.Unpack(rng):
        return ("RangeImage", rng)

    # If it's neither of the above, return Unknown
    return ("Unknown", any_msg)


def rangeImageToXYZ(ri):
    """
    Convert RangeImage data to a list of voxels with X, Y, Z coordinates.
    """
    max_pixel_x = ri.width - 1
    max_pixel_y = ri.height - 1
    fov_h = math.radians(ri.fov_horizontal)
    fov_v = math.radians(ri.fov_vertical)

    voxels = []

    for pixel_x in range(ri.width):
        for pixel_y in range(ri.height):
            pixel_value = ri.image_pixel_data[pixel_y * ri.width + pixel_x]
            if pixel_value == 0:
                # No data for this pixel
                continue

            yaw_rad = (pixel_x / max_pixel_x) * fov_h - fov_h / 2
            pitch_rad = (pixel_y / max_pixel_y) * fov_v - fov_v / 2
            distance_meters = pixel_value * ri.image_pixel_scale

            x = distance_meters * math.cos(pitch_rad) * math.cos(yaw_rad)
            y = distance_meters * math.cos(pitch_rad) * math.sin(yaw_rad)
            z = -distance_meters * math.sin(pitch_rad)

            voxel = {
                "yaw": yaw_rad,  # yaw in radians
                "pitch": pitch_rad, # pitch in radians
                "distance": distance_meters, # distance in meters
                "x": x, # x coordinate in meters
                "y": y, # y coordinate in meters
                "z": z # z coordinate in meters
            }

            voxels.append(voxel)
    return voxels


def saveXYZ(voxels, file_path):
    """
    Save the list of voxels to a file in XYZ format.
    Each voxel is represented as a line with x, y, z coordinates.
    """
    with open(file_path, 'w') as f:
        for voxel in voxels:
            x = voxel['x']
            y = voxel['y']
            z = voxel['z']
            f.write(f"{x} {y} {z}\n")
    print(f"Saved {len(voxels)} voxels to {file_path}")

def saveImage(bmpImg, file_path: str):
    """
    Save the BitmapImageGreyscale8 data to a file.
    The data is saved as a grayscale image in PGM format.
    """
    with open(file_path, 'wb') as f:
        f.write(b'P2\n') # PGM format identifier
        f.write(f"{bmpImg.width} {bmpImg.height}\n".encode()) # Write the width and height
        f.write(b'255\n')  # Max pixel value for PGM
        # Write pixel data
        for y in range(bmpImg.height-1, 0, -1): # Flip the image vertically
            for x in range(bmpImg.width):
                pixel_value = bmpImg.image_pixel_data[y * bmpImg.width + x]
                f.write(f"{pixel_value} ".encode())
            f.write(b'\n')
    print(f"Saved BitmapImage to {file_path}")


def handle_packet(data: bytes, save: bool = False, save_path: str = ""):
    # Parse the RIP1 framing to get the Protobuf payload
    payload = parse_rip1_packet(data)
    if payload is None:
        return  # skip invalid packets

    # Decode the Protobuf message
    result = decode_protobuf_packet(payload)
    if not result:
        print("Unknown or invalid Protobuf message received.")
        return

    msg_type, msg_obj = result
    #print(f"Received '{msg_type}' from {addr}")

    if msg_type == "BitmapImageGreyscale8":
        # Print out main fields
        print("  BitmapImageGreyscale8 data:")
        print(f"    Type: {msg_obj.type}")
        print(f"    Width x Height:  {msg_obj.width} x {msg_obj.height}")
        print(f"    Horizontal FoV:  {msg_obj.fov_horizontal}")
        print(f"    Vertical FoV:    {msg_obj.fov_vertical}")

        # Header info
        seq_id = msg_obj.header.sequence_id
        dt = msg_obj.header.timestamp.ToDatetime()
        print(f"    Sequence ID:     {seq_id}")
        print(f"    Timestamp (UTC): {dt.isoformat()}")

        # Data
        if save:
            filename = f"sonar_image_{seq_id}.pgm"
            file_path = os.path.join(save_path, filename)
            saveImage(msg_obj, file_path)

    elif msg_type == "RangeImage":
        # Print out main fields
        print("  RangeImage data:")
        print(f"    Width x Height:    {msg_obj.width} x {msg_obj.height}")
        print(f"    Horizontal FoV:    {msg_obj.fov_horizontal}")
        print(f"    Vertical FoV:      {msg_obj.fov_vertical}")
        print(f"    image_pixel_scale: {msg_obj.image_pixel_scale}")

        # Header info
        seq_id = msg_obj.header.sequence_id
        dt = msg_obj.header.timestamp.ToDatetime()
        print(f"    Sequence ID:         {seq_id}")
        print(f"    Timestamp (UTC):     {dt.isoformat()}")

        # Convert to XYZ coordinates
        voxels = rangeImageToXYZ(msg_obj)
        print(f"    Voxel count:         {len(voxels)}")
        if save:
            # Save to XYZ file
            filename = f"sonar_voxels_{seq_id}.xyz"
            file_path = os.path.join(save_path, filename)
            saveXYZ(voxels, file_path)

    else:
        # We don't have a custom handler for other message types
        print(
            "  Received an unknown message type (not RangeImage or BitmapImage).")

    print()  # Extra blank line for readability


def parse_file(filename, save: bool = False):
    """
    Listen for Sonar 3D-15 UDP multicast packets on a specific port.
    - Filters packets based on the known Sonar IP address.
    - Parses the RIP1 framing.
    - Decodes the Protobuf message.
    - Prints relevant info (e.g. dimension, FoV, timestamp).
    """
    # Set up a UDP socket with multicast membership

    with open(filename, 'rb') as f:
        content = f.read()

    # If we are saving data, create a directory for the files
    # Get the basename of the file without the extension
    # and use it as the directory name
    save_path = os.path.splitext(os.path.basename(filename))[0]
    if save:
        os.makedirs(save_path, exist_ok=True)


    packets = content.split(b'RIP1')
    for pkt in packets:

        # Parse the RIP1 framing to get the Protobuf payload
        handle_packet(b'RIP1' + pkt, save=save, save_path=save_path)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(
        description="Decode Sonar 3D-15 data from file or from multicast.")
    parser.add_argument(
        "--save",
        action="store_true",
        help="Save RangeImage data to XYZ file format and BitmapImage to PGM file format."
    )
    parser.add_argument(
        "--file",
        type=str,
        default="",
        help="Filename to parse."
    )
    # Parse arguments
    args = parser.parse_args()
    if args.file:
        # Parse a file instead of listening to multicast
        print(f"Parsing file: {args.file}")
        # Verify the file exists
        try:
            with open(args.file, 'rb') as f:
                pass
        except FileNotFoundError:
            print(f"File not found: {args.file}")
            exit(1)

        parse_file(args.file, save=args.save)
        exit(0)
    else:
        print("No file specified. Use --file to specify a file to parse.")
        exit(1)
